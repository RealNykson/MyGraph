using MyGraph.Utilities;
using MyGraph.ViewModels;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Media;

namespace MyGraph.Models
{
  abstract class Connection : CanvasItem
  {
    public double MarginStrength = 100;
    public double OffsetInput = 2.5;
    public double OffsetOutput = 3;
    public double spacing = 23;

    private NodeVM _Start;
    public NodeVM Start
    {
      get
      {
        return _Start;
      }
      set
      {
        if (_Start != null)
        {
          _Start.Outputs.Remove(this);
        }

        _Start = value;
        if (value != null)
        {
          value.Outputs.Add(this);
        }

      }
    }


    private NodeVM _End;
    public NodeVM End
    {
      get
      {
        return _End;
      }
      set
      {
        if (_End != null)
        {
          _End.Inputs.Remove(this);
        }

        _End = value;
        if (value != null)
        {
          value.Inputs.Add(this);
          return;
        }

      }
    }

    public Point startPos
    {
      get => Get<Point>();
      set => Set(value);
    }

    public PointCollection CurvePoints
    {

      get => Get<PointCollection>();
      set => Set(value);
    }
    public void orderConnections()
    {
      List<Connection> orderList = End.Inputs.OrderBy(c => c.Start.Position.Y).ToList();
      if (!orderList.SequenceEqual(End.Inputs))
      {
        End.Inputs.Clear();
        End.Height = Start.MinHeight;
        foreach (Connection con in orderList)
        {
          End.Inputs.Add(con);
        }
      }
       orderList = Start.Outputs.OrderBy(c => c.End.Position.Y).ToList();
      if (!orderList.SequenceEqual(Start.Outputs))
      {
        Start.Outputs.Clear();
        Start.Height = Start.MinHeight;
        foreach (Connection con in orderList)
        {
          Start.Outputs.Add(con);
        }
      }



    }

    public void moveStart(double deltaX, double deltaY)
    {

      Debug.Assert(CurvePoints.Count == 3);
      startPos = new Point(startPos.X + deltaX, startPos.Y + deltaY);
      CurvePoints[0] = new Point(CurvePoints[0].X + deltaX, CurvePoints[0].Y + deltaY);
    }

    public void moveEnd(double deltaX, double deltaY)
    {



      Debug.Assert(CurvePoints.Count == 3);
      CurvePoints[1] = new Point(CurvePoints[1].X + deltaX, CurvePoints[1].Y + deltaY);
      CurvePoints[2] = new Point(CurvePoints[2].X + deltaX, CurvePoints[2].Y + deltaY);

      //Easy way to trigger WPF render refresh because PointCollection dont recognize change
      Point _startPos = startPos;
      startPos = new Point();
      startPos = _startPos;
    }
    public void moveStartAbsolute(double newPosX, double newPosY)
    {
      Debug.Assert(CurvePoints.Count == 3);
      startPos = new Point(newPosX, newPosY);
      CurvePoints[0] = new Point(newPosX + MarginStrength, newPosY);
    }

    public void moveEndAbsolute(double newPosX, double newPosY)
    {

      Debug.Assert(CurvePoints.Count == 3);
      CurvePoints[1] = new Point(newPosX - MarginStrength, newPosY);
      CurvePoints[2] = new Point(newPosX, newPosY);

      //Easy way to trigger WPF render refresh because PointCollection dont recognize change
      Point _startPos = startPos;
      startPos = new Point();
      startPos = _startPos;
    }


    /// <summary>
    /// Updates the position of the connection when a new input/output is added
    /// </summary>
    /// <param name="node">The node that needs to be updated</param>
    /// <param name="connectionList">Either Inputs or Outputs of the given node</param>
    public double getNewYPosition(NodeVM node, ObservableCollection<Connection> connectionList)
    {
      int index = connectionList.IndexOf(this) + 1;
      Debug.Assert(CurvePoints.Count == 3);

      double middlePoint = (double)(connectionList.Count() + 1) / 2;
      int modifier = middlePoint > index ? -1 : +1;
      double stepCount = Math.Abs(middlePoint - index);

      double newPosition = (double)(spacing * modifier) * stepCount;
      double maxPositionInsideNode = (double)(node.Height / 2) - spacing;

      //if (newPosition > maxPositionInsideNode)
      //{
      //  node.Height += spacing;
      //  node.updateInputs();
      //  node.updateOutputs();
      //}

      return newPosition + node.Position.Y + (double)(node.Height / 2);

    }

    public void updateInput()
    {
      double PositionX = End.Position.X - OffsetInput;
      double PositionY = getNewYPosition(End, End.Inputs);
      CurvePoints[1] = new Point(PositionX - MarginStrength, PositionY);
      CurvePoints[2] = new Point(PositionX, PositionY);

      Point _startPos = startPos;
      startPos = new Point();
      startPos = _startPos;

    }
    public void updateOutput()
    {
      double PositionOutputX = Start.Position.X + Start.Width + OffsetOutput;
      double PositionOutputY = getNewYPosition(Start, Start.Outputs);

      startPos = new Point(PositionOutputX, PositionOutputY);
      CurvePoints[0] = new Point(PositionOutputX + MarginStrength, PositionOutputY);
    }

    public Connection(NodeVM output, NodeVM input)
    {
      Debug.Assert(output != null);

      CurvePoints = new PointCollection();
      CurvePoints.Add(new Point());
      CurvePoints.Add(new Point());
      CurvePoints.Add(new Point());
      CurvePoints.Changed += CurvePoints_Changed;

      Start = output;
      End = input;

    }

    private void CurvePoints_Changed(object sender, EventArgs e)
    {

    }

    public abstract void Delete();



  }
}
